package com.mycompany.ocp.ch3.genericsandcollections.collections;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class ListMethods {
    public static void main(String[] args) {
        //List Implementations

        //ArrayList похож на изменяемый массив. Главная выгода ArrayList в том, что мы можем посмотреть элемент in
        //constant time (это O(1)). Однако добавление или удаление элементов медленнее, чем просмотр. Это делает
        //ArrayList хорошим выбором, когда мы читаем чаще, чем записываем.

        //Big O Notation
        //==============================================================================================================
        //O(1) - constant time (постоянное время). Неважно какая большая коллекция, ответ замейт одно и то же время.
        //Например, поиск из коллекции string literal "Panda" будет constant time (я так понимаю, это то же самое, как
        //чтение из массива, т.е. чтение идет по указателю, который в ОЗУ, указатель уникальный, за счет этого
        //получается O(1)).

        //O(log n) - logarithmic time (логарифмическое время). Логарифм - это математическая функция, которая растет
        //намного медленнее, чем размер данных (например, log(8) получается 2³, log(1024) получается 2 в 10 степени).
        //Дело в том, что логарифмическое время быстрее, чем линейное. Binary search работает в логарифмическом времени.

        //O(n) - linear time (линейное время). Производительность будет расти линейно с размером коллекции. Перебор листа
        //и возврат числа элементов, соответствующих "Panda" будет брать линейное время.

        //O(n²) - n squared time (n квадратное время). Код, который имеет вложенные лупы, где каждый луп идет через данные
        //берет n квадратное время. Пример, положить каждую пару "Panda" вместе увидеть если они будут делиться экспонатом

        //O(n³) - n cubed time (n кубическое время). Этот код по производительности работает медленнее O(n²). Код,
        //который имеет вложенный луп, в нем еще луп, где каждый луп идет через n квадратное время.

        //O(2n) - exponential time (экспоненциальное время). Это худший вариант алгоритма, от которого надо
        // избавляться. Экспоненциальное время растет так быстро, что мы рассматриваем эти алгоритмы как невыполнимые.
        // Они пригодны для очень немногих типов входных данных и требуют значительной вычислительной мощности, если
        // только объем данных не до смешного мал. Не помогут ни оптимизация каждого аспекта программного кода, ни
        // использование суперкомпьютеров. Сокрушительное экспоненциальное время делает эти алгоритмы бесперспективными.

        //O(n!) - factorial time (факториальное время). Алгоритмы с экспоненциальным и факториальным временем ужасны,
        // но они нужны для выполнения самых трудных вычислительных задач — знаменитых недетерминированных
        // полиномиальных (NP-полных) задач.
        //==============================================================================================================

        //LinkedList особенный, поскольку реализовывает и List, и Queue. Он имеет все методы List. И также добавляет
        //методы добавления/удаления с начала/конца листа. Главная выгода LinkedList в том, что добавлять и удалять с
        //начала/конца он может в constant time. Однако в произвольном доступе индекс будет брать линейное время (O(n)).

        //Раньше до ArrayList использовался Vector, который работал медленнее из потокобезоасности, которой нет в
        // ArrayList. Как и Vector использовался Stack, который наследуется от Vector. Если нужен stack, надо использовать
        //ArrayDeque. Vector и Stack использовать не нужно!!!

        List<String> list = new ArrayList<>();
        list.add("SD");
        list.add(0, "NY");
        list.set(1, "FL");
        list.remove("NY");
        list.remove(0);

        List<String> list1 = new LinkedList<>();
        list1.add("OH");
        list1.add("CO");
        String state = list1.get(0);
        int index = list1.indexOf("CO");





    }
}
